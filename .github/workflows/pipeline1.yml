name: DevSecOps Pipeline - Example Voting App

on:
  push:
    branches: [ "main" ]
  pull_request:

jobs:
  # ====================
  # 1. Build & Tests (VM1 - Runner CI)
  # ====================
  build-test:
    runs-on: self-hosted
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      # Construire les services avec Docker
      - name: Build Docker Images
        run: |
          docker compose -f docker-compose.yml build

      # Tests unitaires / fonctionnels via Docker (si présents)
#      - name: Run Tests
#        run: |
#          docker compose -f docker-compose.yml run --rm vote pytest
#          docker compose -f docker-compose.yml run --rm result npm test

  # ====================
  # 2. Analyse statique (Semgrep)
  # ====================
  static-analysis:
    runs-on: self-hosted
    needs: build-test
    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Semgrep Scan
        run: |
          docker run --rm -v $(pwd):/src returntocorp/semgrep semgrep --config=auto /src

  # ====================
  # 3. Analyse de composition logicielle (SCA - Trivy, Syft)
  # ====================
  sca-scan:
    runs-on: self-hosted
    needs: static-analysis
    steps:
      - name: Syft SBOM
        run: |
          docker run --rm -v $(pwd):/src anchore/syft:latest dir:/src -o json > sbom.json

      - name: Trivy FS Scan
        run: |
          docker run --rm -v $(pwd):/src aquasec/trivy fs /src

  # ====================
  # 4. Packaging & Scan image
  # ====================
  package-and-scan:
    runs-on: self-hosted
    needs: sca-scan
    steps:
      - name: Build Docker Images
        run: docker compose -f docker-compose.yml build

      - name: Trivy Image Scan
        run: |
          docker images -q | xargs -n1 -I {} docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy image {}

      - name: Push Images to Harbor
        run: |
          echo ${{ secrets.HARBOR_PASSWORD }} | docker login ${{ secrets.HARBOR_URL }} -u ${{ secrets.HARBOR_USERNAME }} --password-stdin
          docker compose -f docker-compose.yml push

  # ====================
  # 5. Déploiement Préprod (VM3)
  # ====================
  deploy-preprod:
    runs-on: self-hosted
    needs: package-and-scan
    steps:
      - name: Deploy Preprod via Swarm
        run: |
          ssh user@vm3 "docker stack deploy -c /home/user/docker-compose-preprod.yml votingapp-preprod"

      - name: OWASP ZAP Scan
        run: |
          docker run --rm -t owasp/zap2docker-stable zap-baseline.py -t http://vm3:8081

      - name: Load Testing with K6
        run: |
          docker run --rm -i loadimpact/k6 run - <tests/load-test.js

  # ====================
  # 6. Validation manuelle
  # ====================
  manual-approval:
    runs-on: self-hosted
    needs: deploy-preprod
    steps:
      - name: Wait for manual approval
        uses: hmarr/auto-approve-action@v3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

  # ====================
  # 7. Déploiement Production (VM4)
  # ====================
  deploy-prod:
    runs-on: self-hosted
    needs: manual-approval
    steps:
      - name: Deploy Production via Swarm
        run: |
          ssh user@vm3 "docker stack deploy -c /home/user/docker-compose-prod.yml votingapp-prod"

  # ====================
  # 8. Supervision (Prometheus + Grafana sur la VM2)
  # ====================
  monitoring:
    runs-on: self-hosted
    needs: deploy-prod
    steps:
      - name: Verify Monitoring
        run: |
          curl -s http://vm2:9090/api/v1/status/config  # Prometheus
          curl -s http://vm2:3000/api/health            # Grafana
